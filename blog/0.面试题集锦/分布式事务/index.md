# 分布式事务

实现分布式事务的方案比较多，常见的比如基于 XA 协议的 2PC、3PC，基于业务层的 TCC，还有应用消息队列 + 消息表实现的最终一致性方案，还有今天要说的 Seata 中间件

> XA协议：定义了一个TM和多个RM之间的通讯协议

##  1、2PC 两阶段提交

> 2: 两阶段 P：prepare 准备 c：commit提交

+ 准备阶段（prepare phase）：TM给每个参与者发送prepare消息，每个数据库参与者在本地执行事务，并写本地的undo/redo log， 此时，事务还没有提交
+ 提交阶段（commit phare）：如果TM收到参与者失败或者超时消息， 直接发送回滚， 否则就发送提交 


### XA方案 


整个2PC事务流程涉及到三个角色，AP、RM、TM ， AP：应用程序，RM：资源管理器，控制分支事务， TM：事务管理器：控制全局事务

1. 数据库层面实现的
2. 需要本地数据支持XA协议
4. 优点：对代码侵入小，就像操作本地事务一样
5. 缺点：强一致性、同步阻塞（刚性事务）
6. 缺点：TM宕机会让RM一直处于阻塞锁定状态


### seata方案

1. 开源的分布式事务框架
2. 对业务0侵入方式 
3. 是应用层面的中间件
4. 性能较好，且不会长时间占用连接资源
5. 提供2PC和TCC方式解决方案 


TC-TM-RM

TC： 事务协调器， 独立的中间件，可独立运行部署，维护全局事务的运行状态
TM： 事务管理器，嵌入到应用程序中，负责开启全局事务，并最终向TC发起全局提交/回滚指令
RM： 资源分支事务，执行本地的提交和回滚


## 2、3PC 三阶段提交

1. 对2PC进行改进，
2. 当TM宕机不会让RM一直处于阻塞锁定状态 
3. 缺点： 多了一次网络通讯，性能变差


> 所以 2PC 和 3PC 都不能保证数据100%一致，因此一般都需要有定时扫描补偿机制。

## 3、TCC

try:预处理， comfirm：确认，cancel：撤销

try都成功了默认就是confirm必须成功，

TCC框架： Hmily



## 4、可靠消息最终一致性

当事务发起方执行完本地事务后并发送一条消息到消息中间件，事务的参与方（消息的消费者）一定能够接收到消息并处理成功。

此方案强调只要消息发给事务参与方最终事务要达到一致

使用方案RocketMQ

### RocketMQ 事务消息

1. 发送方发送一条事务消息到mq中
2. mq收到消息给发送方返回收到消息
3. 发送方执行commit成功后告知mq更新消息状态可消费
4. mq提供事务回查接口
5. 订阅方监听mq消息，通过ack确认机制


## 5、最大努力通知

1. 尽最大努力去通知你
2. 倘若通知不到， 提供一个结果的反查接口

